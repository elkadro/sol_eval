{"prompt":"Write a Solidity function to convert a given amount to Wad (10^18).","code":"function toWad(uint256 amount) public pure returns (uint256) {\n    return amount * 1e18;\n}","tests":[{"input":[1],"output":"1000000000000000000"},{"input":[7],"output":"7000000000000000000"},{"input":[0],"output":"0"}]}
{"prompt":"Write a Solidity function to multiply two Wei numbers (10^27 x 10^27) and output a 10^27 number.","code":"function multiplyWei(uint256 a, uint256 b) public pure returns (uint256) {\n    return (a * b) / 1e27;\n}","tests":[{"input":["500000000000000000000000000","300000000000000000000000000"],"output":"Result of multiplication: 150000000000000000000000000"},{"input":["1000000000000000000000000000","2000000000000000000000000000"],"output":"Result of multiplication: 2000000000000000000000000000"},{"input":["0","500000000000000000000000000"],"output":"Result of multiplication: 0"}]}
{"prompt":"Write a Solidity function to divide two Wei numbers.","code":"function divideWei(uint256 numerator, uint256 denominator) public pure returns (uint256) {\n    require(denominator != 0, \"Cannot divide by zero\");\n    return (numerator * 1e27) / denominator;\n}","tests":[{"input":["500000000000000000000000000","250000000000000000000000000"],"output":"Result of division: 2e27"},{"input":["1000000000000000000000000000","500000000000000000000000"],"output":"Result of division: 2e27"},{"input":["0","500000000000000000000000000"],"output":"Result of division: 0"}]}
{"prompt":"Write a Solidity function that adds two numbers.","code":"function add(uint256 a, uint256 b) public pure returns (uint256) {\n    return a + b;\n}","tests":[{"input":[2,3],"output":5},{"input":[10,15],"output":25},{"input":[0,7],"output":7}]}
{"prompt":"Implement a Solidity function to convert a given amount to Wei (10^27).","code":"function toWei(uint256 amount) public pure returns (uint256) {\n    return amount * 1e27;\n}","tests":[{"input":[1],"output":"1000000000000000000000000000"},{"input":[5],"output":"5000000000000000000000000000"},{"input":[0],"output":"0"}]}
{"prompt":"Concatenate two strings.","code":"function concatenateStrings(string memory str1, string memory str2) public pure returns (string memory) {\n    return string(abi.encodePacked(str1, str2));\n}","tests":[{"input":["Hello","World"],"output":"Concatenate 'Hello' and 'World': 'HelloWorld'"},{"input":["Solidity"," is fun!"],"output":"Concatenate 'Solidity' and ' is fun!': 'Solidity is fun!'"}]}
{"prompt":"Compare two strings by keccak256.","code":"function compareStrings(string memory str1, string memory str2) public pure returns (bool) {\n    return keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2));\n}","tests":[{"input":["Hello","Hello"],"output":"Compare 'Hello' and 'Hello': true"},{"input":["Solidity"," is fun!"],"output":"Compare 'Solidity' and ' is fun!': false"}]}
{"prompt":"Convert a string to bytes32 using keccak256.","code":"function convertToBytes32(string memory str) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(str));\n}","tests":[{"input":["Hello"],"output":"Convert 'Hello' to bytes32: 0x... (bytes32 hash)"},{"input":["Solidity is fun!"],"output":"Convert 'Solidity is fun!' to bytes32: 0x... (bytes32 hash)"}]}
{"prompt":"Write a Solidity function to push an element into a state array.","code":"uint256[] public numberArray;\n\nfunction pushElement(uint256 element) public {\n    numberArray.push(element);\n}","tests":[{"input":[5],"output":"Pushed element 5 into the array"},{"input":[10],"output":"Pushed element 10 into the array"},{"input":[3],"output":"Pushed element 3 into the array"}]}
{"prompt":"Write a Solidity function to get an element from the array.","code":"function getElement(uint256 index) public view returns (uint256) {\n    require(index < numberArray.length, \"Index out of bounds\");\n    return numberArray[index];\n}","tests":[{"input":[0],"output":"Get element at index 0: 5"},{"input":[1],"output":"Get element at index 1: 10"},{"input":[2],"output":"Get element at index 2: 3"}]}
{"prompt":"Implement a Solidity function that mints a specified amount of an ERC20 token.","code":"import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MintableToken is ERC20 {\n    address public admin;\n\n    constructor() ERC20(\"MintableToken\", \"MT\") {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n\n    function mint(address to, uint256 amount) public onlyAdmin {\n        _mint(to, amount);\n    }\n}","tests":[{"input":["0xAddress1",100],"output":"Mint 100 tokens to 0xAddress1"},{"input":["0xAddress2",50],"output":"Mint 50 tokens to 0xAddress2"},{"input":["0xAddress3",200],"output":"Mint 200 tokens to 0xAddress3"}]}
{"prompt":"Write a Solidity modifier that checks if the caller has access control.","code":"contract AccessControlExample {\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n\n    function exampleFunction() public onlyAdmin {\n        // Function logic for admin only\n    }\n}","tests":[{"input":["0xAdminAddress"],"output":"Caller with admin address can call the function"},{"input":["0xNonAdminAddress"],"output":"Caller without admin address cannot call the function"}]}
{"prompt":"Write a Solidity function that sets an address in a mapping(address => address) while preventing the address input from being zero.","code":"mapping(address => address) public addressMapping;\n\nfunction setAddress(address key, address value) public {\n    require(key != address(0), \"Input address cannot be zero\");\n    addressMapping[key] = value;\n}","tests":[{"input":["0xKey1","0xValue1"],"output":"Set address 0xValue1 for key 0xKey1"},{"input":["0xKey2","0xValue2"],"output":"Set address 0xValue2 for key 0xKey2"},{"input":["0xKey3","0xValue3"],"output":"Set address 0xValue3 for key 0xKey3"}]}
{"prompt":"Write a Solidity function that deletes an address from the mapping(address => address) while preventing the address input from being zero.","code":"function deleteAddress(address key) public {\n    require(key != address(0), \"Input address cannot be zero\");\n    delete addressMapping[key];\n}","tests":[{"input":["0xKey1"],"output":"Delete address for key 0xKey1"},{"input":["0xKey2"],"output":"Delete address for key 0xKey2"},{"input":["0xKey3"],"output":"Delete address for key 0xKey3"}]}
{"prompt":"Write a Solidity function that gets the address from the mapping(address => address).","code":"function getAddress(address key) public view returns (address) {\n    return addressMapping[key];\n}","tests":[{"input":["0xKey1"],"output":"Get address for key 0xKey1: 0xValue1"},{"input":["0xKey2"],"output":"Get address for key 0xKey2: 0xValue2"},{"input":["0xKey3"],"output":"Get address for key 0xKey3: 0xValue3"}]}
{"prompt":"Write a Solidity function that sets a bytes32 in a mapping(address => bytes32). It takes a string as a parameter and then does keccak256(bytes(string)) to save it into the mapping as bytes32.","code":"mapping(address => bytes32) public bytes32Mapping;\n\nfunction setBytes32(address key, string memory value) public {\n    bytes32 hashedValue = keccak256(bytes(value));\n    bytes32Mapping[key] = hashedValue;\n}","tests":[{"input":["0xKey1","StringValue1"],"output":"Set bytes32 for key 0xKey1: HashedValue1"},{"input":["0xKey2","StringValue2"],"output":"Set bytes32 for key 0xKey2: HashedValue2"},{"input":["0xKey3","StringValue3"],"output":"Set bytes32 for key 0xKey3: HashedValue3"}]}
{"prompt":"Write a Solidity function that deletes a bytes32 from the mapping(address => bytes32).","code":"function deleteBytes32(address key) public {\n    delete bytes32Mapping[key];\n}","tests":[{"input":["0xKey1"],"output":"Delete bytes32 for key 0xKey1"},{"input":["0xKey2"],"output":"Delete bytes32 for key 0xKey2"},{"input":["0xKey3"],"output":"Delete bytes32 for key 0xKey3"}]}
{"prompt":"Write a Solidity function that gets the bytes32 from the mapping(address => bytes32).","code":"function getBytes32(address key) public view returns (bytes32) {\n    return bytes32Mapping[key];\n}","tests":[{"input":["0xKey1"],"output":"Get bytes32 for key 0xKey1: HashedValue1"},{"input":["0xKey2"],"output":"Get bytes32 for key 0xKey2: HashedValue2"},{"input":["0xKey3"],"output":"Get bytes32 for key 0xKey3: HashedValue3"}]}
{"prompt":"Write a Solidity function to get the address from a mapping(uint256 => address).","code":"mapping(uint256 => address) public indexToAddressMapping;\n\nfunction getAddress(uint256 index) public view returns (address) {\n    return indexToAddressMapping[index];\n}","tests":[{"input":[1],"output":"Get address for index 1: 0xAddress1"},{"input":[2],"output":"Get address for index 2: 0xAddress2"},{"input":[3],"output":"Get address for index 3: 0xAddress3"}]}
{"prompt":"Write a Solidity function to set an address in a mapping(uint256 => address) and prevent zero address.","code":"function setAddress(uint256 index, address value) public {\n    require(value != address(0), \"Input address cannot be zero\");\n    indexToAddressMapping[index] = value;\n}","tests":[{"input":[1,"0xNewAddress1"],"output":"Set address for index 1: 0xNewAddress1"},{"input":[2,"0xNewAddress2"],"output":"Set address for index 2: 0xNewAddress2"},{"input":[3,"0xNewAddress3"],"output":"Set address for index 3: 0xNewAddress3"}]}
{"prompt":"Write a Solidity function to delete an address from the mapping(uint256 => address) by index.","code":"function deleteAddress(uint256 index) public {\n    delete indexToAddressMapping[index];\n}","tests":[{"input":[1],"output":"Delete address for index 1"},{"input":[2],"output":"Delete address for index 2"},{"input":[3],"output":"Delete address for index 3"}]}